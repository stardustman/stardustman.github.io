<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>X86 on stardustman</title><link>http://stardustman.github.io/tags/x86/</link><description>Recent content in X86 on stardustman</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 08 Jun 2020 08:09:12 +0800</lastBuildDate><atom:link href="http://stardustman.github.io/tags/x86/index.xml" rel="self" type="application/rss+xml"/><item><title>asm-how-computer-startup</title><link>http://stardustman.github.io/2020/06/08/asm-how-computer-startup/</link><pubDate>Mon, 08 Jun 2020 08:09:12 +0800</pubDate><guid>http://stardustman.github.io/2020/06/08/asm-how-computer-startup/</guid><description>x86 架构计算机是如何启动的？ 16-bit Processors and Segmentation (1978) The IA-32 architecture family was preceded by 16-bit processors, the 8086 and 8088. The 8086 has 16-bit registers and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to the 8086 except it has an 8-bit external data bus. The 8086/8088 introduced segmentation to</description></item><item><title>x86-64-architecture</title><link>http://stardustman.github.io/2019/10/16/x86-64-architecture/</link><pubDate>Wed, 16 Oct 2019 13:59:24 +0800</pubDate><guid>http://stardustman.github.io/2019/10/16/x86-64-architecture/</guid><description>操作系统其实很大一部分面向 CPU 来编程的。一些 OS 的概念直接来源于 CPU 的术语，或者和 CPU 关联性非常大。要想彻底理解 OS ，无法绕过 CPU。因为 Intel 的 X86(Intel 80386 之后</description></item></channel></rss>