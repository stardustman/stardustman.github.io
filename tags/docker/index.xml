<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on stardustman</title><link>http://stardustman.github.io/tags/docker/</link><description>Recent content in docker on stardustman</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 24 Dec 2019 13:02:03 +0800</lastBuildDate><atom:link href="http://stardustman.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>katacoda-what-is-a-container</title><link>http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/</link><pubDate>Tue, 24 Dec 2019 13:02:03 +0800</pubDate><guid>http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/</guid><description>Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&amp;hellip;] docker run &amp;ndash;help -d, &amp;ndash;detach Run container in background and print container ID &amp;ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台</description></item><item><title>katacoda-what-is-a-container-image</title><link>http://stardustman.github.io/2019/11/26/katacoda-what-is-a-container-image/</link><pubDate>Tue, 26 Nov 2019 20:12:23 +0800</pubDate><guid>http://stardustman.github.io/2019/11/26/katacoda-what-is-a-container-image/</guid><description>container image A container image is a tar file containing tar files. Each of the tar file is a layer. Once all tar files have been extract into the same location then you have the container&amp;rsquo;s filesystem. container image 是一个 tar 文件. 每一个 tar 文件就是一个 layer docker pull 拉取一个镜像 docker pull redis:3.2.11-alpine 3.2.11-alpine: Pulling</description></item><item><title>docker-practice</title><link>http://stardustman.github.io/2019/09/03/docker-practice/</link><pubDate>Tue, 03 Sep 2019 14:20:16 +0800</pubDate><guid>http://stardustman.github.io/2019/09/03/docker-practice/</guid><description>Centos7 Linux 运行的 Docker 容器是: mssql-node-docker-demo-app docker info #(docker-info) docker inspect [ { &amp;quot;Id&amp;quot;: &amp;quot;405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655&amp;quot;, &amp;quot;Created&amp;quot;: &amp;quot;2019-08-01T02:57:14.067532309Z&amp;quot;, &amp;quot;Path&amp;quot;: &amp;quot;/bin/sh&amp;quot;, &amp;quot;Args&amp;quot;: [ &amp;quot;-c&amp;quot;, &amp;quot;/bin/bash ./entrypoint.sh&amp;quot; ], &amp;quot;State&amp;quot;: { &amp;quot;Status&amp;quot;: &amp;quot;running&amp;quot;, &amp;quot;Running&amp;quot;: true, &amp;quot;Paused&amp;quot;: false, &amp;quot;Restarting&amp;quot;: false, &amp;quot;OOMKilled&amp;quot;: false, &amp;quot;Dead&amp;quot;: false, &amp;quot;Pid&amp;quot;: 12164, &amp;quot;ExitCode&amp;quot;: 0, &amp;quot;Error&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;StartedAt&amp;quot;: &amp;quot;2019-08-22T06:08:43.334320939Z&amp;quot;, &amp;quot;FinishedAt&amp;quot;: &amp;quot;2019-08-21T09:25:32.130119566Z&amp;quot; }, &amp;quot;Image&amp;quot;: &amp;quot;sha256:e600f86aa4e2aced43a193a28aa507651bfb77daa09ca8dbf286451a630cf27e&amp;quot;, // node-web-app 的 docker 镜像 id &amp;quot;ResolvConfPath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/resolv.conf&amp;quot;, &amp;quot;HostnamePath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/hostname&amp;quot;, &amp;quot;HostsPath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/hosts&amp;quot;,</description></item><item><title>building-docker-image</title><link>http://stardustman.github.io/2019/05/16/building-docker-image/</link><pubDate>Thu, 16 May 2019 17:33:01 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/building-docker-image/</guid><description>Docker images are built based on a Dockerfile. A Dockerfile defines all the steps required to create a Docker image with your application configured and ready to be run as a container. The image itself contains everything, from operating system to dependencies and configuration required to run your application. Having everything within the image allows you to migrate images between different environments and be confident that if it works in one environment, then it will work in another.</description></item><item><title>deploy-static-website</title><link>http://stardustman.github.io/2019/05/16/deploy-static-website/</link><pubDate>Thu, 16 May 2019 16:17:51 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/deploy-static-website/</guid><description>Create a Dockerfile Docker Images start from a base image. The base image should include the platform dependencies required by your application, for example, having the JVM or CLR installed. This base image is defined as an instruction in the Dockerfile. Docker Images are built based on the contents of a Dockerfile. The Dockerfile is a list of instructions describing how to deploy your application.
# base image FROM nginx:alpine # copies the content of the current directory into a particular location (/usr/share/nginx/html)inside the container.</description></item><item><title>katacoda-deploying-first-docker-container</title><link>http://stardustman.github.io/2019/05/16/katacoda-deploying-first-docker-container/</link><pubDate>Thu, 16 May 2019 12:40:16 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/katacoda-deploying-first-docker-container/</guid><description>Running a container background(detached) docker search image-name
docker search redis docker run options image-name:version solution1: default latest version
docker run -d redis solution2: version is 3.2
docker run -d redis:3.2 Find running container docker ps docker inspect &amp;lt;container-id&amp;gt; docker logs &amp;lt;container-id&amp;gt; Access redis note: each docker container is sandboxed
solution1: specify host port is 6379 -p host-port:container-post
docker run -d --name redisHostPort -p 6379:6379 redis:latest solution2: specify randomly host port -p container-port</description></item></channel></rss>