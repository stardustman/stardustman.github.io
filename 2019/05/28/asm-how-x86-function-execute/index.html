<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"stardustman.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":240,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="前一阵子去看 java 虚拟机原理, 忽然痛悟到虚拟机也是机器啊, 呵呵也就是个软件而已. 看到 java 方法调用太复杂. 字节码那一套又不太熟悉, 还不如直接去看 C 编译后的汇编代码.目的: 搞明白 X86 架构下函数到底是怎么调用执行的.  assembly syntax for X86gas (gnu assembler syntax), 也就是 AT&amp;T 风格.本文采用该风格">
<meta property="og:type" content="article">
<meta property="og:title" content="asm-how-x86-function-execute">
<meta property="og:url" content="http://stardustman.github.io/2019/05/28/asm-how-x86-function-execute/index.html">
<meta property="og:site_name" content="stardustman">
<meta property="og:description" content="前一阵子去看 java 虚拟机原理, 忽然痛悟到虚拟机也是机器啊, 呵呵也就是个软件而已. 看到 java 方法调用太复杂. 字节码那一套又不太熟悉, 还不如直接去看 C 编译后的汇编代码.目的: 搞明白 X86 架构下函数到底是怎么调用执行的.  assembly syntax for X86gas (gnu assembler syntax), 也就是 AT&amp;T 风格.本文采用该风格">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/stardustman/pictrues/raw/master/img/x86-64-stack.png">
<meta property="og:image" content="https://gitee.com/stardustman/pictrues/raw/master/img/callstack-layout-for-upward-growing-stacks.png">
<meta property="og:image" content="https://gitee.com/stardustman/pictrues/raw/master/img/c-swap-to-asm-swap.png">
<meta property="og:image" content="https://gitee.com/stardustman/pictrues/raw/master/img/asm-execute-graph.png">
<meta property="article:published_time" content="2019-05-28T11:32:16.000Z">
<meta property="article:modified_time" content="2021-02-15T09:12:23.292Z">
<meta property="article:author" content="stardustman">
<meta property="article:tag" content="asm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/stardustman/pictrues/raw/master/img/x86-64-stack.png">


<link rel="canonical" href="http://stardustman.github.io/2019/05/28/asm-how-x86-function-execute/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>asm-how-x86-function-execute | stardustman</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="stardustman" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">stardustman</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#assembly-syntax-for-X86"><span class="nav-number">1.</span> <span class="nav-text">assembly syntax for X86</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gas-gnu-assembler-syntax-%E4%B9%9F%E5%B0%B1%E6%98%AF-AT-amp-T-%E9%A3%8E%E6%A0%BC"><span class="nav-number">1.1.</span> <span class="nav-text">gas (gnu assembler syntax), 也就是 AT&amp;T 风格.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intel-syntax"><span class="nav-number">1.2.</span> <span class="nav-text">intel syntax</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#instruction-suffixes"><span class="nav-number">2.</span> <span class="nav-text">instruction suffixes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#addressing-mode"><span class="nav-number">3.</span> <span class="nav-text">addressing mode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#direct-addressing"><span class="nav-number">3.1.</span> <span class="nav-text">direct addressing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indirect-addressing"><span class="nav-number">3.2.</span> <span class="nav-text">indirect addressing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#register-to-memory"><span class="nav-number">3.2.1.</span> <span class="nav-text">register to memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memory-to-register"><span class="nav-number">3.2.2.</span> <span class="nav-text">memory to register</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#program-counter-for-stored-program"><span class="nav-number">4.</span> <span class="nav-text">program counter for stored program</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#change-control-flow"><span class="nav-number">5.</span> <span class="nav-text">change control flow</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jmp-label"><span class="nav-number">5.1.</span> <span class="nav-text">jmp label</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stack-management"><span class="nav-number">6.</span> <span class="nav-text">stack management</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stack-pointer"><span class="nav-number">6.1.</span> <span class="nav-text">stack pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pushl-eax"><span class="nav-number">6.2.</span> <span class="nav-text">pushl %eax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#popl-eax"><span class="nav-number">6.3.</span> <span class="nav-text">popl %eax</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#function-call-and-return"><span class="nav-number">7.</span> <span class="nav-text">function call and return</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#call"><span class="nav-number">7.1.</span> <span class="nav-text">call </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret"><span class="nav-number">7.2.</span> <span class="nav-text">ret</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#call-stack"><span class="nav-number">8.</span> <span class="nav-text">call stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#example"><span class="nav-number">8.1.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#code-analysis"><span class="nav-number">9.</span> <span class="nav-text">code analysis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-compare-to-Assembly"><span class="nav-number">10.</span> <span class="nav-text">C compare to  Assembly</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#asm-execute-graph"><span class="nav-number">11.</span> <span class="nav-text">asm execute graph</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bombs"><span class="nav-number">12.</span> <span class="nav-text">bombs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#references"><span class="nav-number">13.</span> <span class="nav-text">references</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stardustman</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/stardustman" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stardustman" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:aoyunyoung@gmail.com" title="E-Mail → mailto:aoyunyoung@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/9112817/cloud-young" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;9112817&#x2F;cloud-young" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



        </section>
      </div>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/stardustman" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://stardustman.github.io/2019/05/28/asm-how-x86-function-execute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stardustman">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stardustman">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          asm-how-x86-function-execute
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-28 19:32:16" itemprop="dateCreated datePublished" datetime="2019-05-28T19:32:16+08:00">2019-05-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-02-15 17:12:23" itemprop="dateModified" datetime="2021-02-15T17:12:23+08:00">2021-02-15</time>
      </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>7 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>前一阵子去看 java 虚拟机原理, 忽然痛悟到虚拟机也是机器啊, 呵呵也就是个软件而已. 看到 java 方法调用太复杂. 字节码那一套又不太熟悉, 还不如直接去看 C 编译后的汇编代码.<br>目的: 搞明白 X86 架构下函数到底是怎么调用执行的.</p>
</blockquote>
<h1 id="assembly-syntax-for-X86"><a href="#assembly-syntax-for-X86" class="headerlink" title="assembly syntax for X86"></a>assembly syntax for X86</h1><h2 id="gas-gnu-assembler-syntax-也就是-AT-amp-T-风格"><a href="#gas-gnu-assembler-syntax-也就是-AT-amp-T-风格" class="headerlink" title="gas (gnu assembler syntax), 也就是 AT&amp;T 风格."></a>gas (gnu assembler syntax), 也就是 AT&amp;T 风格.</h2><p>本文采用该风格.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="keyword">int</span>, <span class="keyword">int</span>):</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">        movl    %esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">        movl    <span class="number">-20</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">        movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, <span class="number">-20</span>(%rbp)</span><br><span class="line">        movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">        movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<h2 id="intel-syntax"><a href="#intel-syntax" class="headerlink" title="intel syntax"></a>intel syntax</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="keyword">int</span>, <span class="keyword">int</span>):</span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">20</span>], <span class="built_in">edi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>], <span class="built_in">esi</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">20</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">20</span>], <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>], <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">nop</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">rbp</span></span><br><span class="line">        <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<h1 id="instruction-suffixes"><a href="#instruction-suffixes" class="headerlink" title="instruction suffixes"></a>instruction suffixes</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>byte</td>
<td>8bit</td>
</tr>
<tr>
<td>w</td>
<td>word</td>
<td>16bit</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
<td>32bit</td>
</tr>
<tr>
<td>q</td>
<td>quad</td>
<td>64bit</td>
</tr>
</tbody></table>
<h1 id="addressing-mode"><a href="#addressing-mode" class="headerlink" title="addressing mode"></a>addressing mode</h1><blockquote>
<p>CPU 寻址方式, 也就是拿到数据的方式.</p>
</blockquote>
<h2 id="direct-addressing"><a href="#direct-addressing" class="headerlink" title="direct addressing"></a>direct addressing</h2><blockquote>
<p>movb $0x05,%al<br>表示为:R[al] = 0x05;<br>将立即数 0x05(1 byte) 复制到寄存器 al</p>
</blockquote>
<h2 id="indirect-addressing"><a href="#indirect-addressing" class="headerlink" title="indirect addressing"></a>indirect addressing</h2><blockquote>
<p>间接寻址也就是到内存里去找</p>
</blockquote>
<h3 id="register-to-memory"><a href="#register-to-memory" class="headerlink" title="register to memory"></a>register to memory</h3><blockquote>
<p>movl %eax, -4(%ebp)<br>表示为: mem[R[ebp]-4] = R[eax];<br>将寄存器 eax 里面的值复制到寄存器 ebp 的值减去 4 指向的内存地址处(也就是 R[ebp] -4 的值是一个内存地址).<br>通过寄存器指向了内存地址, 是不是很熟悉的指针啊, 对, 就是指针. C 语言的指针就是这么玩的啊!</p>
</blockquote>
<h3 id="memory-to-register"><a href="#memory-to-register" class="headerlink" title="memory to register"></a>memory to register</h3><blockquote>
<p>movl -4(%ebp), %eax<br>%eax 表示为: R[eax] = mem[R[ebp] -4];<br>将寄存器 esp 的值减去 4 的值指向的内存地址处存放的值, 复制到寄存器 eax</p>
</blockquote>
<h1 id="program-counter-for-stored-program"><a href="#program-counter-for-stored-program" class="headerlink" title="program counter for stored program"></a>program counter for stored program</h1><blockquote>
<p>PC = PC + (instruction size in bytes)<br>(instruction) (src1) (src2) (dst)<br>In most processors, the PC is incremented after fetching an instruction,<br>and holds the memory address of (“points to”) the next instruction that would be executed.<br>这里就用到了指令周期(instruction cycle)这个概念了, fetch, decode, execute.<br>注意到 PC 这个寄存器, 在 CPU fetch 了一条指令后就自动增加了.<br>(In a processor where the incrementation precedes the fetch, the PC points to the current instruction being executed.)<br>同样的在 CPU fetch 一条指令之前, PC 指向当前正在执行的指令.<br>注意: 不允许直接操作 ip(instruction pointer) 也叫 pc(program counter) 这个寄存器, 如果这个能被编译器操作的话, 就完全想跳到哪执行就跳到哪执行了. 实际上 call 和 ret 指令就是在间接操作这两个寄存器. call 带来的效果之一就是 push %rip, ret 带来的效果之一就是 pop %rip. 两者具有对称作用啊!</p>
</blockquote>
<h1 id="change-control-flow"><a href="#change-control-flow" class="headerlink" title="change control flow"></a>change control flow</h1><h2 id="jmp-label"><a href="#jmp-label" class="headerlink" title="jmp label"></a>jmp label</h2><blockquote>
<p>When a jump instruction executes (in the last step of the machine cycle), it puts a new address into the PC. Now the fetch at the top of the next machine cycle fetches the instruction at that new address. Instead of executing the instruction that follows the jump instruction in memory, the processor “jumps” to an instruction somewhere else in memory.<br>jmp 指令把 label 所在的地址, 复制给 pc 寄存器. 这就改变了程序的控制流. 然后程序流程就脱离了原来的执行流. 和 call label 很相似, 对, call指令作用之一就包括了一个隐式的 jmp label. 函数调用也就是把控制权交给了被调用者. 但是控制权要回到调用函数那里. 只不过 call 指令在函数交出控制权之前还多干了一件事, 就是把此时的 pc 值 push 到了栈里. </p>
</blockquote>
<h1 id="stack-management"><a href="#stack-management" class="headerlink" title="stack management"></a>stack management</h1><h2 id="stack-pointer"><a href="#stack-pointer" class="headerlink" title="stack pointer"></a>stack pointer</h2><blockquote>
<p>A stack register is a computer central processor register whose purpose is to keep track of a call stack.<br>push pop 指令操作的是 sp(stack pointer) 这个寄存器.<br>栈底地址: 由bp(base pointer) 保存<br>栈分配空间: sp 减去需要的地址空间大小(所谓的栈向下生长);<br>栈回收空间: sp 加上需要的地址空间大小(所谓的栈向上收缩);(PS: 相当无聊的话)</p>
</blockquote>
<p><img src="https://gitee.com/stardustman/pictrues/raw/master/img/x86-64-stack.png" alt="x86-64-stack"> #(x86-64-stack)</p>
<h2 id="pushl-eax"><a href="#pushl-eax" class="headerlink" title="pushl %eax"></a>pushl %eax</h2><blockquote>
<p>push value of %eax onto stack<br>The push instruction places its operand onto the top of the hardware supported stack in memory. Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address [ESP]. ESP (the stack pointer) is decremented by push since the x86 stack grows down - i.e. the stack grows from high addresses to lower addresses.<br>这里可以看到 push 的是多字节的数据, 那就涉及到怎样排列多字节数据的问题了. 也就是所谓的字节序的问题. X86 采用所谓的小端, 也就是把数字按照顺序放到栈里, 数字的高位放在了比较大的内存地址那里.(这里不做讨论)<br>等价于</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subl $4, %esp &#x2F;&#x2F;分配4个字节的空间, 所谓的栈向下生长</span><br><span class="line">movl %eax, (%esp) &#x2F;&#x2F;将 eax 的值复制到 esp 指到的内存地址处</span><br></pre></td></tr></table></figure>
<h2 id="popl-eax"><a href="#popl-eax" class="headerlink" title="popl %eax"></a>popl %eax</h2><blockquote>
<p>pop %eax off stack<br>The pop instruction removes the 4-byte data element from the top of the hardware-supported stack into the specified operand (i.e. register or memory location). It first moves the 4 bytes located at memory location [ESP] into the specified register or memory location, and then increments SP by 4.<br>等价于</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl (%esp),%eax &#x2F;&#x2F;将 esp 指向的内存地址里面的值复制到 eax</span><br><span class="line">addl $4,%esp &#x2F;&#x2F;回收空间</span><br></pre></td></tr></table></figure>

<h1 id="function-call-and-return"><a href="#function-call-and-return" class="headerlink" title="function call and return"></a>function call and return</h1><h2 id="call"><a href="#call" class="headerlink" title="call "></a>call <label></h2><blockquote>
<p>The call instruction first pushes the current code location onto the hardware supported stack in memory(see the push instruction for details), and then performs an unconditional jump to the code location indicated by the label operand. Unlike the simple jump instructions, the call instruction saves the location to return to when the subroutine completes.<br>注意到 CPU 在 fetch 到 call 指令后, PC 就已经自动加 1 了. 此时的 PC 值也就是所谓的函数返回地址. call 指令做了两件事, 第一件事: 将此时的 ip 保存到栈中, 第二件事: jump 到 label 位置, 此时已经改变了 PC 的值.<br>call label 作用等价于:<br>pushq %rip<br>jmp label</p>
</blockquote>
<h2 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h2><blockquote>
<p>The ret instruction implements a subroutine return mechanism. This instruction first pops a code location off the hardware supported in-memory stack (也就是 call 指令压入栈中的 PC, 将这个值复制到 PC 寄存器)(see the pop instruction for details). It then performs an unconditional jump to the retrieved code location.<br>所以啊, call(含有一个 push 操作) 和 ret(含有一个 pop 操作) 指令, 这是实现控制流跳转和恢复的关键. 也间接操作了 sp 这个寄存器. 硬件实现的功能, 不需要过多的计较.<br>ret 作用等价于:<br>popq %rip</p>
</blockquote>
<h1 id="call-stack"><a href="#call-stack" class="headerlink" title="call stack"></a>call stack</h1><blockquote>
<p>In computer science, a call stack is a stack data structure that stores information about the active subroutines of a computer program. This kind of stack is also known as an execution stack, program stack, control stack, run-time stack, or machine stack, and is often shortened to just “the stack”.<br>A call stack is used for several related purposes, but the main reason for having one is to keep track of the point to which each active subroutine should return control when it finishes executing.<br>An active subroutine is one that has been called but is yet to complete execution after which control should be handed back to the point of call. Such activations of subroutines may be nested to any level (recursive as a special case), hence the stack structure.</p>
</blockquote>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><blockquote>
<p>for example, a subroutine DrawSquare calls a subroutine DrawLine from four different places, DrawLine must know where to return when its execution completes. To accomplish this, the address following the instruction that jumps to DrawLine, the return address, is pushed onto the call stack with each call.</p>
</blockquote>
<p><img src="https://gitee.com/stardustman/pictrues/raw/master/img/callstack-layout-for-upward-growing-stacks.png" alt="callstack-layout-for-upward-growing-stacks"> #(callstack-layout-for-upward-growing-stacks)</p>
<h1 id="code-analysis"><a href="#code-analysis" class="headerlink" title="code analysis"></a>code analysis</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 64 bit 机器 , AT&amp;T 风格的汇编</span><br><span class="line">swap(int, int):</span><br><span class="line">        pushq   %rbp &#x2F;&#x2F; 上一个栈帧(main)的基地址压栈 等价于 subq $8, %rsp; movq %rbp,(%rsp)</span><br><span class="line">        movq    %rsp, %rbp &#x2F;&#x2F; 开辟新的函数栈帧, 也就是形成一个新的栈的基地址</span><br><span class="line">        movl    %edi, -20(%rbp) &#x2F;&#x2F; 参数 a</span><br><span class="line">        movl    %esi, -24(%rbp) &#x2F;&#x2F; 参数 b</span><br><span class="line">        movl    -20(%rbp), %eax &#x2F;&#x2F; 把 a 赋值给 %eax</span><br><span class="line">        movl    %eax, -4(%rbp)  &#x2F;&#x2F; 把 %eax (a)赋值给 %rbp - 4(a) 的地址处</span><br><span class="line">        movl    -24(%rbp), %eax &#x2F;&#x2F; 把 b 赋值给 % eax（b）</span><br><span class="line">        movl    %eax, -20(%rbp) &#x2F;&#x2F; 把 %eax (b) 赋值给 %rbp - 20（b） 的地址处,完成 b 的交换</span><br><span class="line">        movl    -4(%rbp), %eax  &#x2F;&#x2F; 把 %rbp - 4 地址处的值(a) 赋值给 %eax (a)</span><br><span class="line">        movl    %eax, -24(%rbp) &#x2F;&#x2F; 把 %eax (a) 赋值给 %rbp - 24 的地址处, 完成 a 的交换</span><br><span class="line">        nop &#x2F;&#x2F; 延时</span><br><span class="line">        popq    %rbp &#x2F;&#x2F; 等价于 movq (%rsp), %rbp ; 上一个函数栈帧(main)的基地址恢复; addq $8, %rsp ; 上一个函数的 %rsp 恢复</span><br><span class="line">        ret &#x2F;&#x2F; 1. popq %rip. (恢复 main 的 pc, call swap 这条指令压入的 pc ) 2. jmp % rip 处继续执行.(也就是 movl $0, %eax 这条指令的地址)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swap(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    $2, %esi &#x2F;&#x2F; 由 caller 准备函数参数 2</span><br><span class="line">        movl    $1, %edi &#x2F;&#x2F; 由 caller 准备函数参数 1</span><br><span class="line">        call    swap &#x2F;&#x2F; 在 CPU fetch 了 call 指令后, pc 已经指向了下一条指令, 也就是 movl $0, %eax 这条指令. 此时的 call 指令完成了两件事, 第一件事: 将 pc(old) 压入到栈中(swap 函数 ret 指令(函数返回)就是把这个 pc(old) pop 到 pc 这个寄存器, CPU 就能接着执行 movl $0, %eax 这条指令了), 第二件事: jump 到swap的地址, 开始执行swap的代码.</span><br><span class="line">        movl    $0, %eax &#x2F;&#x2F; 返回值 0 </span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<h1 id="C-compare-to-Assembly"><a href="#C-compare-to-Assembly" class="headerlink" title="C compare to  Assembly"></a>C compare to  Assembly</h1><p><img src="https://gitee.com/stardustman/pictrues/raw/master/img/c-swap-to-asm-swap.png" alt="c-swap-to-asm-swap"></p>
<h1 id="asm-execute-graph"><a href="#asm-execute-graph" class="headerlink" title="asm execute graph"></a>asm execute graph</h1><p><img src="https://gitee.com/stardustman/pictrues/raw/master/img/asm-execute-graph.png" alt="asm-execute-graph"></p>
<blockquote>
<p>注意: 示意图里面的是 64 bit 的汇编代码.<br>注意: 所有的 push 和 pop 指令都会改变 sp 寄存器的值.<br>图1 main 函数执行完 pushq %rbp 和 movq %rsp, %rbp, 开辟 main 函数的栈帧.<br>图2 main 函数执行 call swap. call 指令两个作用: 1. 将 movl $0, %eax 这条指令的地址(X)压入栈中. 2. jump 到 swap 的地址.<br>图3 是 swap 函数的栈帧, 此时新函数的栈帧 rsp 和 rbp 指向的是相同的内存地址.<br>图4 所有的 mov 使用的内存地址, 都是通过 rbp 来偏移得到, rbp 的值并没有发生改变.<br>图5 执行完 popq %rsp, 恢复 main 函数的栈基址(rbp), 也就是和图1 一样.<br>图6 执行完 ret 恢复为 main 函数的栈帧(这里主要是 rsp, rbp, pc, 个人理解把 pc 视为栈帧的一部分, 因为函数调用控制权发生转移, 幕后也离不开 pc 这个寄存器的变化). ret 的作用等价于 popq %rip. 但是无法直接操作 ip(pc) 这个寄存器. 也就相当于间接改变 ip. 此时 pc 已被 ret 指令恢复成了 X. (此时实际上已经控制权已经回到 main 函数了), 接下来就是继续执行 main 函数的代码. 其实 swap 函数的栈帧已经被销毁了. 也就是再也访问不到 swap 函数里的变量了. 这就是 C 语言里的所谓的本地变量的本质.<br>注意: 图1 和 图6 , 图2 和 图5 完全一样, 这不是有意为之, 按照 X86 的函数调用机制就是这样的. 在被调用函数(swap)执行 popq % rbp, 这条指令就是要恢复调用函数(main)的 rbp, 执行 ret 这条指令就是要恢复调用函数(main)的下一条指令的地址. 也就是将 pc 的值恢复为 X, 这样就可以接着执行了嘛. 也就是所谓的恢复调用者(main)的栈帧. 也就是 main 函数调用 swap 函数(call 指令)保留 main 的状态(也就是 main 函数的 rbp 和 pc), swap 执行到最后(popq, ret)负责恢复现场(也就是恢复 main 函数的 rbp 和 pc). call 和 ret 指令的也分别有 push %rip 和 pop %rip 的作用. 很对称的操作!</p>
</blockquote>
<h1 id="bombs"><a href="#bombs" class="headerlink" title="bombs"></a>bombs</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp  ; 保留上一个函数(也就是调用者)的栈基址</span><br><span class="line">movq    %rsp, %rbp ; 新函数的栈基址. 一个新的栈帧 sp 和 bp 指向的是同一个地址</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个所谓的栈帧(stack frame)就是由 sp(stack pointer) 和 bp(base pointer) 这两个寄存器来维护的.<br>这两句会出现在每一个函数的开始, 那么问题来了 main 函数里面保留的是哪一个调用函数的栈基址呢? 个人推测, 不一定正确, 我们知道创建进程(线程)是 OS 内核的功能, 当然进程销毁也是内核的功能. 内核同样维护着属于内核空间的栈帧, 当进程创建完毕后, 我们写的 C 代码应该是被内核里的函数调用的, 这样的话 main 里面 pushq %rbp 应该是保留的内核函数的栈基址. 这样 main 的 ret 返回后就能接着执行内核函数里面的逻辑了. (估计也就是销毁进程一系列操作了, 这样才能把分配的资源收回来啊!)</p>
</blockquote>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Program_counter">program counter</a></li>
<li><a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/classes/sp10/cse141/pdf/02/S01_x86_64.key.pdf">A reader’s guide to x86 assembly</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86 guide</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instruction_cycle">instruction cycle</a></li>
<li><a target="_blank" rel="noopener" href="http://chortle.ccsu.edu/assemblytutorial/Chapter-17/ass17_2.html">how jump work</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack">call stack</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bogotobogo.com/cplusplus/stackunwinding.php">stack-winding(push)-unwinding(pop)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bogotobogo.com/cplusplus/assembly.php">understand-heap-assembly</a></li>
<li><a target="_blank" rel="noopener" href="https://keleshev.com/eax-x86-register-meaning-and-history/">eax-x86-register-meaning-and-history</a></li>
<li><a target="_blank" rel="noopener" href="https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">flint.cs.yale.edu/cs421/papers/x86-asm/asm.html</a></li>
<li><a target="_blank" rel="noopener" href="https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm">at&amp;t 语法</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/asm/" rel="tag"><i class="fa fa-tag"></i> asm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/28/linux-kernel-analysis-1/" rel="prev" title="linux-kernel-analysis-1">
                  <i class="fa fa-chevron-left"></i> linux-kernel-analysis-1
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/05/31/linux-kernel-analysis-2/" rel="next" title="linux-kernel-analysis-2">
                  linux-kernel-analysis-2 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stardustman</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Symbols count total">201k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:03</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
