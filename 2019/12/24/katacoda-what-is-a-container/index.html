<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>katacoda-what-is-a-container - stardustman</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="stardust"><meta name=description content="Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&amp;hellip;] docker run &amp;ndash;help -d, &amp;ndash;detach Run container in background and print container ID &amp;ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.111.3 with theme even"><link rel=canonical href=http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="katacoda-what-is-a-container"><meta property="og:description" content="Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&mldr;] docker run &ndash;help -d, &ndash;detach Run container in background and print container ID &ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台"><meta property="og:type" content="article"><meta property="og:url" content="http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-12-24T13:02:03+08:00"><meta property="article:modified_time" content="2019-12-24T13:02:03+08:00"><meta itemprop=name content="katacoda-what-is-a-container"><meta itemprop=description content="Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&mldr;] docker run &ndash;help -d, &ndash;detach Run container in background and print container ID &ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台"><meta itemprop=datePublished content="2019-12-24T13:02:03+08:00"><meta itemprop=dateModified content="2019-12-24T13:02:03+08:00"><meta itemprop=wordCount content="1362"><meta itemprop=keywords content="docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="katacoda-what-is-a-container"><meta name=twitter:description content="Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&mldr;] docker run &ndash;help -d, &ndash;detach Run container in background and print container ID &ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>keep writing</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/2022/03/27/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>keep writing</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/2022/03/27/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>katacoda-what-is-a-container</h1><div class=post-meta><span class=post-time>2019-12-24</span>
<span class=more-meta>1362 words</span>
<span class=more-meta>3 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#processes>Processes</a><ul><li><a href=#redis-container>redis container</a></li></ul></li><li><a href=#process-directory>Process Directory</a><ul><li><a href=#redis-server-进程的配置>redis-server 进程的配置</a></li></ul></li><li><a href=#namespace>namespace</a><ul><li><a href=#lanched-contained-processes>lanched &ldquo;contained&rdquo; processes</a></li><li><a href=#namespace-是啥>namespace 是啥</a></li></ul></li><li><a href=#cgroups>CGroups</a><ul><li><a href=#查看-redis-server-的-cgroups>查看 redis-server 的 CGroups</a></li><li><a href=#查看所有的-cgroups>查看所有的 CGroups</a></li><li><a href=#配置-cgroups>配置 cgroups</a></li></ul></li><li><a href=#seccomp-限制可以使用的-syscall>Seccomp 限制可以使用的 syscall</a></li><li><a href=#capabilities>Capabilities</a></li><li><a href=#reference>Reference</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=processes>Processes</h2><blockquote><p>Containers are just normal Linux Processes with additional configuration applied.</p></blockquote><p>容器只是应用了附加配置的普通 Linux 进程。</p><h3 id=redis-container>redis container</h3><h4 id=lanch-redis-server-process>lanch redis-server process</h4><blockquote><p>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&mldr;]
docker run &ndash;help
-d, &ndash;detach Run container in background and print container ID
&ndash;name string Assign a name to the container</p></blockquote><pre><code class=language-sh>docker run -d --name=db redis:alpine
</code></pre><p>在后台启动一个 <code>container name</code> 是 <code>db</code> 的容器, 并打印容器的 <code>ID</code></p><blockquote><p>Unable to find image &lsquo;redis:alpine&rsquo; locally
alpine: Pulling from library/redis
63bc94deeb28: Pull complete
828e397560e3: Pull complete
5902d88df6c2: Pull complete
157b2c953c6d: Pull complete
b5212c16b59d: Pull complete
5f8f01031701: Pull complete
Digest: sha256:613ab7e1c0175cae18b69c291512e5e8f1129175f6617ff2126b7ac9a1e5c550
Status: Downloaded newer image for redis:alpine
0a5ceea3df52e200d45772c4507b20d7c95a97dcd3939cb33a8d5bc1b842e334</p></blockquote><h4 id=检验>检验</h4><h5 id=pidof-process-name>pidof &lt;process-name></h5><pre><code class=language-sh>pidof redis-server
</code></pre><h5 id=ps>ps</h5><pre><code class=language-sh>ps aux | grep redis-server
</code></pre><h5 id=docker-top-container-name>docker top <em>container-name</em></h5><blockquote><p>docker top can help us identify information about the process including the PID (Process ID) and PPID (Parent Process ID)</p></blockquote><pre><code class=language-sh>docker top db
</code></pre><h5 id=pstree>pstree</h5><blockquote><p>pstree will list all of the sub processes</p></blockquote><pre><code class=language-sh>pstree -c -p -A $(pgrep dockerd)
</code></pre><h2 id=process-directory>Process Directory</h2><blockquote><p>Linux is just a series of magic files and contents, this makes it fun to explore and navigate to see what is happening under the covers, and in some cases, change the contents to see the results. The configuration for each process is defined within the /proc directory. If you know the process ID, then you can identify the configuration directory.</p></blockquote><p>每一个 <code>process</code> 的配置都定义在 <code>/proc</code> 文件夹下. 如果知道 <code>process ID</code>, 就能找到该进程的配置文件夹</p><h3 id=redis-server-进程的配置>redis-server 进程的配置</h3><h4 id=找到-redis-server-的-pid>找到 redis-server 的 pid</h4><pre><code class=language-sh>DBPID=$(pgrep redis-server)
echo Redis is $DBPID
ls /proc
</code></pre><h4 id=查看-redis-server-进程的环境变量>查看 redis-server 进程的环境变量</h4><pre><code class=language-sh>ls /proc/$DBPID
cat /proc/$DBPID/environ
</code></pre><p>结果如下:</p><blockquote><p>HOSTNAME=f3b9624ce46cSHLVL=2REDIS_DOWNLOAD_SHA=
61db74eabf6801f057fd24b590232f2f337d422280fd19486
eca03be87d3a82bHOME=/home/redisPATH=/usr/local/sb
in:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.7.tar.gzREDIS_VERSION=5.0.7PWD=/data</p></blockquote><p>解析查看:</p><pre><code class=language-javascript>'HOSTNAME=5fba1658e4ceSHLVL=2REDIS_DOWNLOAD_SHA=61db74eabf6801f057fd24b590232f2f337d422280fd19486eca03be87d3a82bHOME=/home/redisPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binREDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.7.tar.gzREDIS_VERSION=5.0.7PWD=/data'.match(/[A-Z]+=[^A-Z]*/g) // regexp 解析查看 key=value
</code></pre><h4 id=docker-容器里执行-env-命令>docker 容器里执行 env 命令</h4><pre><code class=language-sh>docker exec -it db env
</code></pre><p><code>env</code> 内容如下:</p><blockquote><p>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=f3b9624ce46c
TERM=xterm
REDIS_VERSION=5.0.7
REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-5.0.7.tar.gz
REDIS_DOWNLOAD_SHA=61db74eabf6801f057fd24b590232f2f337d422280fd19486eca03be87d3a82b
HOME=/root</p></blockquote><h2 id=namespace>namespace</h2><blockquote><p>One of the fundamental parts of a container is namespaces. The concept of namespaces is to limit what processes can see and access certain parts of the system, such as other network interfaces or processes
When a container is started, the container runtime, such as Docker, will create new namespaces to sandbox the process. By running a process in it&rsquo;s own Pid namespace, it will look like it&rsquo;s the only process on the system.</p></blockquote><ul><li>Mount (mnt)</li><li>Process (pid)</li><li>Network (net)</li><li>Interprocess Communication (ipc)</li><li>UTS (hostnames) aka unix time-sharing system</li><li>User ID (user)</li><li>Control group (cgroup)</li></ul><h3 id=lanched-contained-processes>lanched &ldquo;contained&rdquo; processes</h3><blockquote><p>Without using a runtime such as Docker, a process can still operate within it&rsquo;s own namespace. One tool to help is unshare.</p></blockquote><p>不用 <code>docker</code> 这个 <code>runtime</code>, 也可以用 <code>unshare</code> 这个工具来创建一个拥有自己的 <code>namespace</code> 的进程.</p><pre><code class=language-sh>unshare --help
</code></pre><blockquote><p>Run a program with some namespaces unshared from the parent.</p></blockquote><p>运行一个程序, 不共享父进程的某些 namespaces</p><pre><code class=language-sh>unshare --fork --pid --mount-proc bash
ps
exit
</code></pre><h3 id=namespace-是啥>namespace 是啥</h3><blockquote><p>Namespaces are inode locations on disk. this allows for processes to shared/reused the same namespace, allowing them to view and interact.</p></blockquote><p><code>namespace</code> 是硬盘上的 <code>inode</code>. 这允许 <code>processes</code> 共享/复用相同的 <code>namespace</code>, 允许进程之间可以互相看得到, 互相交流.</p><h4 id=查看-redis-server-的所有-namespace>查看 redis-server 的所有 namespace</h4><pre><code class=language-sh>ls -liha /proc/$DBPID/ns
</code></pre><h4 id=attach-process-to-existing-namespaces>attach process to existing NameSpaces</h4><blockquote><p><code>nsenter</code> run a program with namespaces of other processes.</p></blockquote><p>在其他进程的 <code>namespace</code> 中运行一个程序</p><pre><code class=language-txt>nsenter --help
nsenter [options] [&lt;program&gt; [&lt;argument&gt;...]]
 Options:
 -a, --all              enter all namespaces
 -t, --target &lt;pid&gt;     target process to get namespaces from
 -m, --mount[=&lt;file&gt;]   enter mount namespace
 -u, --uts[=&lt;file&gt;]     enter UTS namespace (hostname etc)
 -i, --ipc[=&lt;file&gt;]     enter System V IPC namespace
 -n, --net[=&lt;file&gt;]     enter network namespace
 -p, --pid[=&lt;file&gt;]     enter pid namespace
 -C, --cgroup[=&lt;file&gt;]  enter cgroup namespace
 -U, --user[=&lt;file&gt;]    enter user namespace
 -S, --setuid &lt;uid&gt;     set uid in entered namespace
 -G, --setgid &lt;gid&gt;     set gid in entered namespace
     --preserve-credentials do not touch uids or gids
 -r, --root[=&lt;dir&gt;]     set the root directory
 -w, --wd[=&lt;dir&gt;]       set the working directory
 -F, --no-fork          do not fork before exec'ing &lt;program&gt;
 -Z, --follow-context   set SELinux context according to --target PID
</code></pre><pre><code class=language-sh>nsenter --target $DBPID --mount --uts --ipc --net --pid ps aux
</code></pre><p>在 <code>redis-server</code> 的 <code>mount</code>, <code>uts</code>, <code>ipc</code>, <code>net</code>, <code>pid</code> 这些命名空间里执行 <code>ps</code> 命令</p><h4 id=share-namespaces-of-redis-server>share namespaces of redis-server</h4><blockquote><p>With Docker, these namespaces can be shared using the syntax container:&lt;container-name>. For example, the command below will connect nginx to the DB namespace</p></blockquote><pre><code class=language-sh>docker run -d --name=web --net=container:db nginx:alpine
</code></pre><p>启动 <code>nginx</code> 的容器. 共享 <code>redis-server</code> 的 <code>net</code> namespace</p><ul><li>查看 <code>nginx</code> 容器的 <code>net</code> 的 namespace</li></ul><pre><code class=language-sh> ls -lha /proc/$WEBPID/ns/ | grep net
</code></pre><blockquote><p>dr-x&ndash;x&ndash;x 2 systemd-network systemd-journal 0 Dec 24 13:40 .
dr-xr-xr-x 9 systemd-network systemd-journal 0 Dec 24 13:40 ..
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 cgroup -> cgroup:[4026531835]
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 ipc -> ipc:[4026532225]
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 mnt -> mnt:[4026532223]
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 net -> net:[4026532160] &ndash; 注意这个是共享的 redis-server 的 net 命名空间
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 pid -> pid:[4026532226]
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 user -> user:[4026531837]
lrwxrwxrwx 1 systemd-network systemd-journal 0 Dec 24 13:40 uts -> uts:[4026532224]</p></blockquote><ul><li>查看 <code>redis-server</code> 容器的 <code>net</code> 命名空间</li></ul><pre><code class=language-sh>ls -lha /proc/$DBPID/ns/ | grep net
</code></pre><blockquote><p>lrwxrwxrwx 1 999 packer 0 Dec 24 13:39 net -> net:[4026532160]</p></blockquote><h2 id=cgroups>CGroups</h2><blockquote><p>CGroups limit the amount of resources a process can consume. These cgroups are values defined in particular files within the /proc directory.
CGroups 用来限制一个进程可以使用的资源的量. cgroups 的值被定义在 /proc 文件夹下的特定文件里.</p></blockquote><h3 id=查看-redis-server-的-cgroups>查看 redis-server 的 CGroups</h3><pre><code class=language-sh>cat /proc/$DBPID/cgroup
</code></pre><ul><li>得到 redis-server 的容器 ID</li></ul><pre><code class=language-sh>DBID=$(docker ps --no-trunc | grep 'db' | awk '{print $1}')
</code></pre><ul><li>查看 redis-server 的 cpu stats 和 usages</li></ul><pre><code class=language-sh>cat /sys/fs/cgroup/cpu,cpuacct/docker/$DBID/cpuacct.stat
</code></pre><ul><li>查看 redis-server 的 cpu shares</li></ul><pre><code class=language-sh>cat /sys/fs/cgroup/cpu,cpuacct/docker/$DBID/cpu.shares
</code></pre><ul><li>查看所有容器的 memory 的 docker cgroups 配置</li></ul><pre><code class=language-sh>ls /sys/fs/cgroup/memory/docker
</code></pre><h3 id=查看所有的-cgroups>查看所有的 CGroups</h3><pre><code class=language-sh> ls /sys/fs/cgroup
</code></pre><h3 id=配置-cgroups>配置 cgroups</h3><blockquote><p>用 cgroups 配置 内存, memory quotes 存放在 memory.limit_in_bytes
这个文件</p></blockquote><ul><li>容器默认没有内存限制</li></ul><pre><code class=language-sh>docker stats db --no-strem ; 只查看一条信息 
</code></pre><ul><li>限制 db 这个容器的内存使用</li></ul><pre><code class=language-sh>echo 8000000 &gt; /sys/fs/cgroup/memory/docker/$DBID/memory.limit_in_bytes
</code></pre><h2 id=seccomp-限制可以使用的-syscall>Seccomp 限制可以使用的 syscall</h2><blockquote><p>When assigned to a process it means the process will be limited to a subset of the ability system calls. If it attempts to call a blocked system call is will recieve the error &ldquo;Operation Not Allowed&rdquo;. <a href=https://github.com/moby/moby/blob/a575b0b1384b2ba89b79cbd7e770fbeb616758b3/profiles/seccomp/default.json>容器默认可以使用的 syscall</a></p></blockquote><pre><code class=language-sh>cat /proc/$DBPID/status
cat /proc/$DBPID/status | grep Seccomp
</code></pre><blockquote><p>The flag meaning are: 0: disabled 1: strict 2: filtering</p></blockquote><h2 id=capabilities>Capabilities</h2><blockquote><p>Capabilities are groupings about what a process or user has permission to do. These Capabilities might cover multiple system calls or actions, such as changing the system time or hostname.</p></blockquote><ul><li>查看 redis-server 的 Capabilities</li></ul><blockquote><p>The status file also containers the Capabilities flag. A process can drop as many Capabilities as possible to ensure it&rsquo;s secure.</p></blockquote><pre><code class=language-sh>cat /proc/$DBPID/status | grep ^Cap
</code></pre><p>结果如下:</p><blockquote><p>CapInh: 00000000a80425fb
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000</p></blockquote><ul><li>解析 redis-server 的 flags</li></ul><blockquote><p>The flags are stored as a bitmask that can be decoded with capsh</p></blockquote><pre><code class=language-sh>capsh --decode=00000000a80425fb
</code></pre><p>解析结果如下:</p><blockquote><p>0x00000000a80425fb=cap_chown,cap_dac_override,cap_fowner,
cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,
cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,
cap_audit_write,cap_setfcap</p></blockquote><h2 id=reference>Reference</h2><ol><li><a href=https://www.katacoda.com/courses/container-runtimes/what-is-a-container>what is a container</a></li><li><a href=http://www.ruanyifeng.com/blog/2018/11/awk.html>awk</a></li></ol></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>stardust</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2019-12-24</span></p><p class=copyright-item><span class=item-title>Markdown</span>
<span class=item-content><a class=link-to-markdown href=http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/index.md target=_blank>The Markdown version »</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/docker/>docker</a></div><nav class=post-nav><a class=prev href=/2019/12/28/master-git/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">master-git</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/2019/11/29/tomcat-http-cookie/><span class="next-text nav-default">tomcat-http-cookie</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=stardustman/comments issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:aoyunyoung@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://stackoverflow.com/users/9112817/cloud-young class="iconfont icon-stack-overflow" title=stack-overflow></a>
<a href=https://github.com/stardustman class="iconfont icon-github" title=github></a>
<a href=http://stardustman.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2019 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>stardust</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>