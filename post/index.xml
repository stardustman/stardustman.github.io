<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on stardustman</title><link>http://stardustman.github.io/post/</link><description>Recent content in Posts on stardustman</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 23 Jul 2024 15:00:13 +0800</lastBuildDate><atom:link href="http://stardustman.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>http://stardustman.github.io/2022/03/27/about/</link><pubDate>Sun, 27 Mar 2022 23:18:39 +0800</pubDate><guid>http://stardustman.github.io/2022/03/27/about/</guid><description>You can&amp;rsquo;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.
The pain you feel when you write is actually the pain of clarifying your thinking.(David Perell)</description></item><item><title>Ipc Unix Domain Socket</title><link>http://stardustman.github.io/2024/07/23/ipc-unix-domain-socket/</link><pubDate>Tue, 23 Jul 2024 15:00:13 +0800</pubDate><guid>http://stardustman.github.io/2024/07/23/ipc-unix-domain-socket/</guid><description>unix domain socket 是啥? A Unix domain socket (UDS) or IPC socket (inter-process communication) is a data communications endpoint for exchanging data between processes executing on the same host operating system. 同一台机器两个不同的进程之间交换数据，优化过的 socket。 问题背景 java 写的</description></item><item><title>Zookeeper Transaction Log</title><link>http://stardustman.github.io/2023/10/21/zookeeper-transaction-log/</link><pubDate>Sat, 21 Oct 2023 14:19:13 +0800</pubDate><guid>http://stardustman.github.io/2023/10/21/zookeeper-transaction-log/</guid><description>分析的 zookeeper 代码版本为 3.9.1 。 zookeer 的 transaction log 为二进制文件，采用的是大端序。 zookeeper 数据持久化的功能在 zookeeper/server/persistence 下。 解析日志就可以获取 zookeeper 的数据。可以用来实现实时备份到另一</description></item><item><title>Ipc Signal</title><link>http://stardustman.github.io/2023/04/11/ipc-signal/</link><pubDate>Tue, 11 Apr 2023 20:15:57 +0800</pubDate><guid>http://stardustman.github.io/2023/04/11/ipc-signal/</guid><description>signal 什么是 signal Signals are various notifications sent to a process in order to notify it of various &amp;ldquo;important&amp;rdquo; events. 信号是发送给进程的各种通知，以便通知它发生了各种“重要”的事件。 有哪些信号？默认怎么处理？ Signal Name Default</description></item><item><title>Asm How Java Byte Code Execute</title><link>http://stardustman.github.io/2023/04/05/asm-how-java-byte-code-execute/</link><pubDate>Wed, 05 Apr 2023 10:35:32 +0800</pubDate><guid>http://stardustman.github.io/2023/04/05/asm-how-java-byte-code-execute/</guid><description>jvm jvm 是一个栈式(stack-based)虚拟计算机。啥意思，就是大多数的 opcode 的操作数在 operand stack 上，执行的结果也放在 oprand stack 上。 有的 opcode 的操作数在 local variable ta</description></item><item><title>Java Jdk Proxy</title><link>http://stardustman.github.io/2023/02/12/java-jdk-proxy/</link><pubDate>Sun, 12 Feb 2023 19:02:31 +0800</pubDate><guid>http://stardustman.github.io/2023/02/12/java-jdk-proxy/</guid><description>分析环境: jdk8 dynamic proxy 是啥？ A dynamic proxy class is a class that implements a list of interfaces1 specified at runtime such that a method invocation through one of the interfaces on an instance of the class will be encoded and dispatched to another object through a uniform interface2. 动态代理类生成调用方法如下： Proxy.newProxyInstance(handler.getClass().getClassLoader(),</description></item><item><title>Algorithm Snowflake</title><link>http://stardustman.github.io/2022/06/25/algorithm-snowflake/</link><pubDate>Sat, 25 Jun 2022 11:43:45 +0800</pubDate><guid>http://stardustman.github.io/2022/06/25/algorithm-snowflake/</guid><description>分布式 ID snowflake 算法使用一个 64bits 的正整数作为 ID。64bits 正整数 layout 如下： package stardustman.github.io; public class SnowFlake { // 起始的时间戳 private final static long START_STAMP = 1480166465631L; // sequence number private final static long SEQUENCE_BIT = 12; // machine id bits private final</description></item><item><title>Master Pki</title><link>http://stardustman.github.io/2022/06/23/master-pki/</link><pubDate>Thu, 23 Jun 2022 22:17:42 +0800</pubDate><guid>http://stardustman.github.io/2022/06/23/master-pki/</guid><description>certificate 目标：绑定 public key 和 name。一切围绕着这个目标来展开。 图解 References 强烈推荐-everything-pki 翻译版-everything-pki ubuntu-trust-store-location decode-an-ssl-certificate c</description></item><item><title>Java Thread Pool Params</title><link>http://stardustman.github.io/2022/06/20/java-thread-pool-params/</link><pubDate>Mon, 20 Jun 2022 22:47:13 +0800</pubDate><guid>http://stardustman.github.io/2022/06/20/java-thread-pool-params/</guid><description>基本策略 关注点分离，任务提交和执行分离。 延迟策略，延迟初始化。 图解 References 你管这破玩意叫线程池</description></item><item><title>Virtual Memory Address Explore</title><link>http://stardustman.github.io/2022/05/22/virtual-memory-address-explore/</link><pubDate>Sun, 22 May 2022 16:26:36 +0800</pubDate><guid>http://stardustman.github.io/2022/05/22/virtual-memory-address-explore/</guid><description>virtual memory address space layout 代码测试 cargo new vas-explore main.rs use std::{thread,time}; fn main() { println!(&amp;quot;Hello, world!&amp;quot;); let sl = time::Duration::from_millis(10000000); thread::sleep(sl); println!(&amp;quot;Goodbye, world!&amp;quot;); } cargo build ./target/debug/vas-explore pidof vas-explore /proc/pid/maps stardust@os:x86_64-linux-gnu$ pidof vas-explore 75599 stardust@os:x86_64-linux-gnu$ cat /proc/75599/maps 556a8a831000-556a8a837000 r--p 00000000 08:12 815699 /home/stardust/Desktop/rust/vas-explore/target/debug/vas-explore 556a8a837000-556a8a86e000 r-xp 00006000 08:12 815699 /home/stardust/Desktop/rust/ vas-explore/target/debug/vas-explore # text(code segment) segment 556a8a86e000-556a8a87c000 r--p 0003d000 08:12 815699 /home/stardust/Desktop/rust/vas-explore/target/debug/vas-explore 556a8a87d000-556a8a880000 r--p 0004b000 08:12 815699 /home/stardust/Desktop/rust/vas-explore/target/debug/vas-explore</description></item><item><title>Linux File Permissions</title><link>http://stardustman.github.io/2022/04/16/linux-file-permissions/</link><pubDate>Sat, 16 Apr 2022 17:33:29 +0800</pubDate><guid>http://stardustman.github.io/2022/04/16/linux-file-permissions/</guid><description>最近在使用 k8s 过程中，需要给 mount 的文件配置权限。 提起 file 的权限只想到 rwx，是不全面的,完整的权限是 rwxsStT。 权限列表 权限导图 特殊权限 setuid Setuid is</description></item><item><title>Githubpage Hugo Website</title><link>http://stardustman.github.io/2022/03/19/githubpage-hugo-website/</link><pubDate>Sat, 19 Mar 2022 16:50:38 +0800</pubDate><guid>http://stardustman.github.io/2022/03/19/githubpage-hugo-website/</guid><description>步骤 安装软件 git # 配置好 git git config --global user.name &amp;quot;your username&amp;quot; git config --global user.email &amp;quot;your email&amp;quot; hugo hugo 创建本地 website 参考：https://gohugo.io/getting-started/qu</description></item><item><title>2022-plan</title><link>http://stardustman.github.io/2022/02/07/2022-plan/</link><pubDate>Mon, 07 Feb 2022 23:32:40 +0800</pubDate><guid>http://stardustman.github.io/2022/02/07/2022-plan/</guid><description> https://www.bilibili.com/video/BV1Cx411S7HJ?p=2 https://see.stanford.edu/Course/CS107 ComputerSystem:A programer perspective Edtion3 English rust-lang kubernetes</description></item><item><title>asm-executable-and-linkable-format</title><link>http://stardustman.github.io/2021/12/25/asm-executable-and-linkable-format/</link><pubDate>Sat, 25 Dec 2021 19:39:41 +0800</pubDate><guid>http://stardustman.github.io/2021/12/25/asm-executable-and-linkable-format/</guid><description>References 彻底理解连接器系列</description></item><item><title>js-eventloop</title><link>http://stardustman.github.io/2021/12/05/js-eventloop/</link><pubDate>Sun, 05 Dec 2021 23:24:48 +0800</pubDate><guid>http://stardustman.github.io/2021/12/05/js-eventloop/</guid><description>References understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript learning-functional-programming-with-javascript what is event loop?js-conf what is event loop demo an-introduction-to-functional-programming how-javascript-works-in-browser-and-node 浏览器提供 Web Apis</description></item><item><title>k8s-deploy-container-using-yaml</title><link>http://stardustman.github.io/2021/11/28/k8s-deploy-container-using-yaml/</link><pubDate>Sun, 28 Nov 2021 10:18:03 +0800</pubDate><guid>http://stardustman.github.io/2021/11/28/k8s-deploy-container-using-yaml/</guid><description>kubernetes 作为一个云上的操作系统，要想充分利用，就要了解 kubernetes 提供的功能。告诉系统要搞啥，k8s 帮你搞定这一切，归根结底，不开发 k8s 就是一个 k8s 的用户，知道</description></item><item><title>What-happens-type-url-into-browser-and-press-enter</title><link>http://stardustman.github.io/2021/09/11/what-happens-type-url-into-browser-and-press-enter/</link><pubDate>Sat, 11 Sep 2021 16:21:12 +0800</pubDate><guid>http://stardustman.github.io/2021/09/11/what-happens-type-url-into-browser-and-press-enter/</guid><description>dns query get the ip of the target domain browser cache firefox(about:networking#dns) /etc/hosts os cache macos 查看 dns 请求日志 sudo log stream &amp;ndash;predicate &amp;lsquo;process == &amp;ldquo;mDNSResponder&amp;rdquo;&amp;rsquo; &amp;ndash;info dns resolver /etc/resolv.conf arp -a 查看有没有 dns 服务器的 mac 地址 ARP request for the nameserver send dns query to get the ip of the domain arp 获取 gateway 的 mac</description></item><item><title>What-happens-when-you-type-google.com-into-your-browser-and-press-enter</title><link>http://stardustman.github.io/2021/09/11/what-happens-when-you-type-google.com-into-your-browser-and-press-enter/</link><pubDate>Sat, 11 Sep 2021 16:21:12 +0800</pubDate><guid>http://stardustman.github.io/2021/09/11/what-happens-when-you-type-google.com-into-your-browser-and-press-enter/</guid><description>dns query get the ip of the target domain browser cache firefox(about:networking#dns) /etc/hosts os cache macos 查看 dns 请求日志 sudo log stream &amp;ndash;predicate &amp;lsquo;process == &amp;ldquo;mDNSResponder&amp;rdquo;&amp;rsquo; &amp;ndash;info dns resolver /etc/resolv.conf arp -a 查看有没有 dns 服务器的 mac 地址 ARP request for the nameserver send dns query to get the ip of the domain arp 获取 gateway 的 mac</description></item><item><title>asm-java-jit</title><link>http://stardustman.github.io/2021/07/18/asm-java-jit/</link><pubDate>Sun, 18 Jul 2021 10:43:46 +0800</pubDate><guid>http://stardustman.github.io/2021/07/18/asm-java-jit/</guid><description>前言 无论多么花里胡哨的功能，最终落地到一台计算机上，都是二进制代码。虽然 java 代码跑在 jvm 平台之上，但是 jvm 只是负责执行 java 自定义的一套 bytecode 的工具，只要</description></item><item><title>java-keyword-volatile</title><link>http://stardustman.github.io/2021/06/18/java-keyword-volatile/</link><pubDate>Fri, 18 Jun 2021 14:54:23 +0800</pubDate><guid>http://stardustman.github.io/2021/06/18/java-keyword-volatile/</guid><description>可见性问题 可见性问题思路 References von-neumann-harvard-architecture out-of-order-execution(dynamic execution) Instruction_scheduling X86/GCC memory fence的一些见解</description></item><item><title>cs-semaphores</title><link>http://stardustman.github.io/2021/05/25/cs-semaphores/</link><pubDate>Tue, 25 May 2021 12:38:06 +0800</pubDate><guid>http://stardustman.github.io/2021/05/25/cs-semaphores/</guid><description/></item><item><title>asm-pointers-and-memory</title><link>http://stardustman.github.io/2021/04/28/asm-pointers-and-memory/</link><pubDate>Wed, 28 Apr 2021 16:04:36 +0800</pubDate><guid>http://stardustman.github.io/2021/04/28/asm-pointers-and-memory/</guid><description>Basic Pointer 为啥需要 Pointer？ 更容易在不同代码段之间共享信息，在不同代码段之间来回复制也是可以的。但用指针的形式更好。 链式数据结构, 如链表和二</description></item><item><title>cs-condition-variables</title><link>http://stardustman.github.io/2021/04/18/cs-condition-variables/</link><pubDate>Sun, 18 Apr 2021 20:44:09 +0800</pubDate><guid>http://stardustman.github.io/2021/04/18/cs-condition-variables/</guid><description>condition variable 是啥？ condition variable 是啥？本质上就是一个状态变量 +队列。现实世界中，想要进行下一步的行动，往往需要满足一定的条件(condition)。如十字路口</description></item><item><title>cs-english-words</title><link>http://stardustman.github.io/2020/12/28/cs-english-words/</link><pubDate>Mon, 28 Dec 2020 15:11:28 +0800</pubDate><guid>http://stardustman.github.io/2020/12/28/cs-english-words/</guid><description>a association a connection or cooperative link between people or organizations allot to assign as a share or portion ad-hoc An ad hoc activity or organization is done or formed only because a situation has made it necessary and is not planned in advance.Ad hoc is a word that originally comes from Latin and means “for this” or &amp;quot;for this situation.&amp;quot; In current</description></item><item><title>cs-lock</title><link>http://stardustman.github.io/2020/12/14/cs-lock/</link><pubDate>Mon, 14 Dec 2020 15:20:26 +0800</pubDate><guid>http://stardustman.github.io/2020/12/14/cs-lock/</guid><description>为啥需要 lock？ 多处理器的存在 中断的存在 lock 是啥？ lock 本质上是一个变量。变量本质上是一块内存。归根结底，lock 就是一块内存，用这块内存来保证</description></item><item><title>cs-cache</title><link>http://stardustman.github.io/2020/12/01/cs-cache/</link><pubDate>Tue, 01 Dec 2020 08:40:29 +0800</pubDate><guid>http://stardustman.github.io/2020/12/01/cs-cache/</guid><description>There can be many caches stacked on top of each other. Cache 可以一层一层累积。 if you miss in one you try in the “lower level cache” Lower level, mean higher number. 在上层的 Cache miss 了，可以在下层的 Cache 去找。依次类推</description></item><item><title>acknowledgement-timeout-retry-sequence-number</title><link>http://stardustman.github.io/2020/11/30/acknowledgement-timeout-retry-sequence-number/</link><pubDate>Mon, 30 Nov 2020 10:54:57 +0800</pubDate><guid>http://stardustman.github.io/2020/11/30/acknowledgement-timeout-retry-sequence-number/</guid><description>TCP 要解决的问题 references tcp-congestion-control tcp-congestion-control-ppt</description></item><item><title>data_and_metadata</title><link>http://stardustman.github.io/2020/11/26/data_and_metadata/</link><pubDate>Thu, 26 Nov 2020 16:18:52 +0800</pubDate><guid>http://stardustman.github.io/2020/11/26/data_and_metadata/</guid><description>具体问题具体分析，确实非常重要。用正确的思想指导行动，才可事半功倍。 现实中的客观问题有意思的地方在于：无论你选择看得见，还是选择看不见，它都</description></item><item><title>notions_of_computer</title><link>http://stardustman.github.io/2020/11/24/notions_of_computer/</link><pubDate>Tue, 24 Nov 2020 13:25:13 +0800</pubDate><guid>http://stardustman.github.io/2020/11/24/notions_of_computer/</guid><description>指导思想 计算机是人发明的。由计算机组成的世界，其设计思想很明显要借鉴现实中的东西。正如一位伟人的著作开篇提出 “谁是我们的敌人？谁是我们的朋友</description></item><item><title>data-structure-btree</title><link>http://stardustman.github.io/2020/06/12/data-structure-btree/</link><pubDate>Fri, 12 Jun 2020 14:11:02 +0800</pubDate><guid>http://stardustman.github.io/2020/06/12/data-structure-btree/</guid><description>B-tree 特性 所有的 leaves 都在同一层级。 B-Tree 被 minimum degree t 定义。t 依赖于 disk block size。 除了 root，其余节点必须至少有 t - 1 个 key。root 节点至少有 1 个 ke</description></item><item><title>asm-how-computer-startup</title><link>http://stardustman.github.io/2020/06/08/asm-how-computer-startup/</link><pubDate>Mon, 08 Jun 2020 08:09:12 +0800</pubDate><guid>http://stardustman.github.io/2020/06/08/asm-how-computer-startup/</guid><description>x86 架构计算机是如何启动的？ 16-bit Processors and Segmentation (1978) The IA-32 architecture family was preceded by 16-bit processors, the 8086 and 8088. The 8086 has 16-bit registers and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to the 8086 except it has an 8-bit external data bus. The 8086/8088 introduced segmentation to</description></item><item><title>data-structure-heap</title><link>http://stardustman.github.io/2020/05/18/data-structure-heap/</link><pubDate>Mon, 18 May 2020 15:24:05 +0800</pubDate><guid>http://stardustman.github.io/2020/05/18/data-structure-heap/</guid><description>线性 or 非线性 数据结构可以分为两大类：线性结构和非线性结构。线性结构典型的就是数组和链表，非线性典型就是树了。复杂的数据结构基本上都是两者的组</description></item><item><title>os-banker's-algorithm</title><link>http://stardustman.github.io/2020/05/13/os-bankers-algorithm/</link><pubDate>Wed, 13 May 2020 15:31:05 +0800</pubDate><guid>http://stardustman.github.io/2020/05/13/os-bankers-algorithm/</guid><description>Banker&amp;rsquo;s Algorithm 银行家算法是什么 银行家主要就是通过放贷来赚钱的。那最重要的问题是啥？当然是把钱借给还得起的人咯。试想，银行把钱都借给了还不起的人，那银行</description></item><item><title>cache-replacement-policy-lru</title><link>http://stardustman.github.io/2020/05/11/cache-replacement-policy-lru/</link><pubDate>Mon, 11 May 2020 08:39:15 +0800</pubDate><guid>http://stardustman.github.io/2020/05/11/cache-replacement-policy-lru/</guid><description>Cache cache 为啥要有 Cache 呢？根本原因是各种存储速度不匹配。或者为了加快某个过程，直接将多次转换的转换结果直接缓存起来，便于再次使用时直接绕开这些转换过</description></item><item><title>network-dhcp</title><link>http://stardustman.github.io/2020/05/09/network-dhcp/</link><pubDate>Sat, 09 May 2020 09:36:27 +0800</pubDate><guid>http://stardustman.github.io/2020/05/09/network-dhcp/</guid><description>DHCP 步骤 Discover Offer Request ACK References 127.0.0.1 和 0.0.0.0 DHCP-Basics full-packet-friday-dhcp dynamic-host-configuration-protocal dhcp-rfc</description></item><item><title>data-structure-red-black-tree</title><link>http://stardustman.github.io/2020/04/27/data-structure-red-black-tree/</link><pubDate>Mon, 27 Apr 2020 08:50:28 +0800</pubDate><guid>http://stardustman.github.io/2020/04/27/data-structure-red-black-tree/</guid><description>
References red-black-tree-visualization</description></item><item><title>network-dns</title><link>http://stardustman.github.io/2020/04/23/network-dns/</link><pubDate>Thu, 23 Apr 2020 10:27:04 +0800</pubDate><guid>http://stardustman.github.io/2020/04/23/network-dns/</guid><description>怎样学习一个新的东西，也可以按照一定的套路的。这个东西解决什么问题？这个东西怎样解决问题？ 还有没有其他方法？ 三步走分析一下 DNS 解决什么问题 根据</description></item><item><title>algorithm-quick-sort</title><link>http://stardustman.github.io/2020/04/14/algorithm-quick-sort/</link><pubDate>Tue, 14 Apr 2020 20:02:16 +0800</pubDate><guid>http://stardustman.github.io/2020/04/14/algorithm-quick-sort/</guid><description>quick sort C 代码 #include &amp;lt;stdio.h&amp;gt; int partition(int* array, int startIndex, int endIndex){ int left = startIndex; int right = endIndex; int pivot = array[startIndex]; int temp = 0; // 第一个 while 循环，其实就是从两个方向遍历一次数组，根据 pivot 进行分割。 while (left != right) { // 第二</description></item><item><title>algorithm-merge-sort</title><link>http://stardustman.github.io/2020/04/10/algorithm-merge-sort/</link><pubDate>Fri, 10 Apr 2020 20:07:39 +0800</pubDate><guid>http://stardustman.github.io/2020/04/10/algorithm-merge-sort/</guid><description>merge sort merge sort C code #include &amp;lt;stdio.h&amp;gt; void merge(int* array, int start, int mid, int end){ // start = 0 // mid = 3 // end = 7 int tempArrayLength = end - start + 1; // 8 int tempArray[tempArrayLength]; // tempArray[8] int p1 = start; // 0 int p2 = mid + 1; // 4 int p = 0; // 比较两个小集合，</description></item><item><title>three-easy-pieces-4-process</title><link>http://stardustman.github.io/2020/01/14/three-easy-pieces-4-process/</link><pubDate>Tue, 14 Jan 2020 10:06:38 +0800</pubDate><guid>http://stardustman.github.io/2020/01/14/three-easy-pieces-4-process/</guid><description>我们知道一个计算机 CPU 数量有限, 但是却可以同时跑数量远远多于 CPU 数量的程序. 其实这就是 virtualizing. 怎样进行 CPU 虚拟化呢? 通过抽象出 process 这个基本概念, 也就是 running program.</description></item><item><title>master-git</title><link>http://stardustman.github.io/2019/12/28/master-git/</link><pubDate>Sat, 28 Dec 2019 13:15:29 +0800</pubDate><guid>http://stardustman.github.io/2019/12/28/master-git/</guid><description>git init Create an empty Git repository or reinitialize an existing one 也即是向 working directory 里添加 .git 文件夹 .git/ ├── branches # git 分支 ├── config # git 配置 ├── description ├── HEAD # HEAD 指针, 指向当前分支最新的 commit ├── hooks │</description></item><item><title>katacoda-what-is-a-container</title><link>http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/</link><pubDate>Tue, 24 Dec 2019 13:02:03 +0800</pubDate><guid>http://stardustman.github.io/2019/12/24/katacoda-what-is-a-container/</guid><description>Processes Containers are just normal Linux Processes with additional configuration applied. 容器只是应用了附加配置的普通 Linux 进程。 redis container lanch redis-server process Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG&amp;hellip;] docker run &amp;ndash;help -d, &amp;ndash;detach Run container in background and print container ID &amp;ndash;name string Assign a name to the container docker run -d --name=db redis:alpine 在后台</description></item><item><title>tomcat-http-cookie</title><link>http://stardustman.github.io/2019/11/29/tomcat-http-cookie/</link><pubDate>Fri, 29 Nov 2019 14:29:51 +0800</pubDate><guid>http://stardustman.github.io/2019/11/29/tomcat-http-cookie/</guid><description>package javax.servlet.http; import java.io.Serializable; import java.security.AccessController; import java.security.PrivilegedAction; import java.text.MessageFormat; import java.util.BitSet; import java.util.Locale; import java.util.ResourceBundle; /** * Creates a cookie, a small amount of information sent by a servlet to a Web * browser, saved by the browser, and later sent back to the server. * 创建一个 cookie， servlet 发给浏览器的一个小信息</description></item><item><title>katacoda-what-is-a-container-image</title><link>http://stardustman.github.io/2019/11/26/katacoda-what-is-a-container-image/</link><pubDate>Tue, 26 Nov 2019 20:12:23 +0800</pubDate><guid>http://stardustman.github.io/2019/11/26/katacoda-what-is-a-container-image/</guid><description>container image A container image is a tar file containing tar files. Each of the tar file is a layer. Once all tar files have been extract into the same location then you have the container&amp;rsquo;s filesystem. container image 是一个 tar 文件. 每一个 tar 文件就是一个 layer docker pull 拉取一个镜像 docker pull redis:3.2.11-alpine 3.2.11-alpine: Pulling</description></item><item><title>bloomfilter</title><link>http://stardustman.github.io/2019/11/22/bloomfilter/</link><pubDate>Fri, 22 Nov 2019 09:05:04 +0800</pubDate><guid>http://stardustman.github.io/2019/11/22/bloomfilter/</guid><description>References bloom filter
bloom filter
https://coderscat.com/bloom-filter/</description></item><item><title>x86-64-architecture</title><link>http://stardustman.github.io/2019/10/16/x86-64-architecture/</link><pubDate>Wed, 16 Oct 2019 13:59:24 +0800</pubDate><guid>http://stardustman.github.io/2019/10/16/x86-64-architecture/</guid><description>操作系统其实很大一部分面向 CPU 来编程的。一些 OS 的概念直接来源于 CPU 的术语，或者和 CPU 关联性非常大。要想彻底理解 OS ，无法绕过 CPU。因为 Intel 的 X86(Intel 80386 之后</description></item><item><title>select_poll_epoll</title><link>http://stardustman.github.io/2019/09/19/select_poll_epoll/</link><pubDate>Thu, 19 Sep 2019 14:43:18 +0800</pubDate><guid>http://stardustman.github.io/2019/09/19/select_poll_epoll/</guid><description>弄清楚 I/O Multiplexing 和 Linux 中 select, poll, epoll 之间的关系. multiplexer Multiplexer is a combinational circuit that has maximum of 2^n data inputs, n selection lines and single output line. One of these data inputs will be connected to the output based on the values of selection lines. Since there are n selection lines, there will be 2^n possible combinations of zeros and</description></item><item><title>wireshark</title><link>http://stardustman.github.io/2019/09/10/wireshark/</link><pubDate>Tue, 10 Sep 2019 09:51:07 +0800</pubDate><guid>http://stardustman.github.io/2019/09/10/wireshark/</guid><description>Wireshark Windows 配置 SSL Version 3.0.3 配置 SSLKEYLOGFILE 系统变量 配置 Wireshark 编辑 -&amp;gt; 首选项 -&amp;gt; Protocols -&amp;gt; TLS 重启 Wireshark 过滤器查看 视图 -&amp;gt; 内部 -&amp;gt; 支持的协议</description></item><item><title>docker-practice</title><link>http://stardustman.github.io/2019/09/03/docker-practice/</link><pubDate>Tue, 03 Sep 2019 14:20:16 +0800</pubDate><guid>http://stardustman.github.io/2019/09/03/docker-practice/</guid><description>Centos7 Linux 运行的 Docker 容器是: mssql-node-docker-demo-app docker info #(docker-info) docker inspect [ { &amp;quot;Id&amp;quot;: &amp;quot;405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655&amp;quot;, &amp;quot;Created&amp;quot;: &amp;quot;2019-08-01T02:57:14.067532309Z&amp;quot;, &amp;quot;Path&amp;quot;: &amp;quot;/bin/sh&amp;quot;, &amp;quot;Args&amp;quot;: [ &amp;quot;-c&amp;quot;, &amp;quot;/bin/bash ./entrypoint.sh&amp;quot; ], &amp;quot;State&amp;quot;: { &amp;quot;Status&amp;quot;: &amp;quot;running&amp;quot;, &amp;quot;Running&amp;quot;: true, &amp;quot;Paused&amp;quot;: false, &amp;quot;Restarting&amp;quot;: false, &amp;quot;OOMKilled&amp;quot;: false, &amp;quot;Dead&amp;quot;: false, &amp;quot;Pid&amp;quot;: 12164, &amp;quot;ExitCode&amp;quot;: 0, &amp;quot;Error&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;StartedAt&amp;quot;: &amp;quot;2019-08-22T06:08:43.334320939Z&amp;quot;, &amp;quot;FinishedAt&amp;quot;: &amp;quot;2019-08-21T09:25:32.130119566Z&amp;quot; }, &amp;quot;Image&amp;quot;: &amp;quot;sha256:e600f86aa4e2aced43a193a28aa507651bfb77daa09ca8dbf286451a630cf27e&amp;quot;, // node-web-app 的 docker 镜像 id &amp;quot;ResolvConfPath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/resolv.conf&amp;quot;, &amp;quot;HostnamePath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/hostname&amp;quot;, &amp;quot;HostsPath&amp;quot;: &amp;quot;/var/lib/docker/containers/405a378d6f88f903dda5972dbfb8f037efff22296c3aaf4c50d44ebd68ad8655/hosts&amp;quot;,</description></item><item><title>clang-structure</title><link>http://stardustman.github.io/2019/07/17/clang-structure/</link><pubDate>Wed, 17 Jul 2019 10:48:46 +0800</pubDate><guid>http://stardustman.github.io/2019/07/17/clang-structure/</guid><description>size of structure reference flexible-array-members-structure-c</description></item><item><title>asm-how-recursion-function-execute</title><link>http://stardustman.github.io/2019/07/06/asm-how-recursion-function-execute/</link><pubDate>Sat, 06 Jul 2019 16:35:51 +0800</pubDate><guid>http://stardustman.github.io/2019/07/06/asm-how-recursion-function-execute/</guid><description>斐波那契数列 问题描述 第一个月初有一对刚诞生的兔子 第二个月之后(第三个月)它们可以生育 每月每对可生育的兔子会诞生下一对新兔子 兔子永不死 问第 n 月</description></item><item><title>asm-clang-concepts</title><link>http://stardustman.github.io/2019/06/25/asm-clang-concepts/</link><pubDate>Tue, 25 Jun 2019 16:57:59 +0800</pubDate><guid>http://stardustman.github.io/2019/06/25/asm-clang-concepts/</guid><description>C 语言里的概念在 X86-64 汇编层面的分析. 汇编风格使用 AT&amp;amp;T 风格. 编译器是 gcc-x86-64-9.1 指针 A pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored at that location is known</description></item><item><title>asm-how-x86-64-arguments-pass</title><link>http://stardustman.github.io/2019/06/24/asm-how-x86-64-arguments-pass/</link><pubDate>Mon, 24 Jun 2019 09:52:27 +0800</pubDate><guid>http://stardustman.github.io/2019/06/24/asm-how-x86-64-arguments-pass/</guid><description>x86-64 下函数参数传递, 汇编层面分析 To pass parameters to the subroutine, we put up to six of them into registers (in order: rdi, rsi, rdx, rcx, r8, r9). If there are more than six parameters to the subroutine, then push the rest onto the stack in reverse order (i.e. last parameter first) – since the stack grows down, the first</description></item><item><title>tools-for-me</title><link>http://stardustman.github.io/2019/06/17/tools-for-me/</link><pubDate>Mon, 17 Jun 2019 18:37:10 +0800</pubDate><guid>http://stardustman.github.io/2019/06/17/tools-for-me/</guid><description>programming java decompiler-Luyten decompiler-cfr byte-code-viewer jclasslib assembly godbolt json json-runoob json-online regexp regexp-jex.im regexp-regexr regexp-regexper hex hex converter hex editor html html beautify base64 base64 code format code format url unicode unicode for you shell oh-my-zsh starship working pc snipaste mubu process on screen-recorder reinstall os multibootusb universal usb installer rufus entertainment video online downloader-you-get downloader-motrix downloader-Xdown converter audio-converter movie cupfox agmov picture waifu2x papers-anwanqi ilovepapers file ilovepdf html to</description></item><item><title>master-ip</title><link>http://stardustman.github.io/2019/06/04/master-ip/</link><pubDate>Tue, 04 Jun 2019 15:32:28 +0800</pubDate><guid>http://stardustman.github.io/2019/06/04/master-ip/</guid><description>Motivation The Internet Protocol is designed for use in interconnected systems of packet-switched computer communication networks. Such a system has been called a &amp;ldquo;catenet&amp;rdquo;. The internet protocol provides for transmitting blocks of data called datagrams from sources to destinations, where sources and destinations are hosts identified by fixed length addresses. The internet protocol also provides for fragmentation and reassembly of long datagrams, if necessary, for transmission through &amp;ldquo;small packet&amp;rdquo; networks.</description></item><item><title>linux-kernel-analysis-2</title><link>http://stardustman.github.io/2019/05/31/linux-kernel-analysis-2/</link><pubDate>Fri, 31 May 2019 09:35:37 +0800</pubDate><guid>http://stardustman.github.io/2019/05/31/linux-kernel-analysis-2/</guid><description>数据连续存储和选择读取</description></item><item><title>asm-how-x86-function-execute</title><link>http://stardustman.github.io/2019/05/28/asm-how-x86-function-execute/</link><pubDate>Tue, 28 May 2019 19:32:16 +0800</pubDate><guid>http://stardustman.github.io/2019/05/28/asm-how-x86-function-execute/</guid><description>前一阵子去看 java 虚拟机原理, 忽然痛悟到虚拟机也是机器啊, 呵呵也就是个软件而已. 看到 java 方法调用太复杂. 字节码那一套又不太熟悉, 还不如直接去看 C 编</description></item><item><title>linux-kernel-analysis-1</title><link>http://stardustman.github.io/2019/05/28/linux-kernel-analysis-1/</link><pubDate>Tue, 28 May 2019 12:25:46 +0800</pubDate><guid>http://stardustman.github.io/2019/05/28/linux-kernel-analysis-1/</guid><description>analysis01 设计理念 机制与策略分离 机制 &amp;ndash; 提供什么样的功能 策略 &amp;ndash; 如何使用这些功能 说实在的这句话第一次听到还是挺震撼的, 一时觉得大学里的操作系统都不知道在</description></item><item><title>ubuntu18.04-install-openjdk8</title><link>http://stardustman.github.io/2019/05/25/ubuntu18.04-install-openjdk8/</link><pubDate>Sat, 25 May 2019 14:33:35 +0800</pubDate><guid>http://stardustman.github.io/2019/05/25/ubuntu18.04-install-openjdk8/</guid><description>添加 openjdk8 的第三方源 sudo add-apt-repository ppa:openjdk-r/ppa ppa (Personal Package Achives) 执行更新 apt-get update 安装 openjdk8 sudo apt-get install openjdk-8-jdk 选择版本 sudo update-alternatives - -config java 确认安装成功 java -version</description></item><item><title>master-tcp</title><link>http://stardustman.github.io/2019/05/22/master-tcp/</link><pubDate>Wed, 22 May 2019 09:18:08 +0800</pubDate><guid>http://stardustman.github.io/2019/05/22/master-tcp/</guid><description>The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and in interconnected systems of such networks. TCP header format basic data transfer reliability sequence number acknowledgement flow control window size multiplexing socket (ip, port) connections Each connection is uniquely specified by a pair of sockets identifying its two sides.(source ip, source port),(destination ip, destination port) sockets sequence</description></item><item><title>git-commands</title><link>http://stardustman.github.io/2019/05/20/git-commands/</link><pubDate>Mon, 20 May 2019 22:33:03 +0800</pubDate><guid>http://stardustman.github.io/2019/05/20/git-commands/</guid><description>git rebase -i HEAD~N 复制提交记录 git branch -f target-branch-name commit-id 切换到 target-branch-name 并指向 commit-id git cherry-pick commit-id1 commit-id2 重新排序提交的记录. cherry-pick 名字起得真是有意思啊. 像捡樱桃似的, 把一个个想要的记录捡到当前分</description></item><item><title>csapp-memory-hierarchy</title><link>http://stardustman.github.io/2019/05/20/csapp-memory-hierarchy/</link><pubDate>Mon, 20 May 2019 14:22:49 +0800</pubDate><guid>http://stardustman.github.io/2019/05/20/csapp-memory-hierarchy/</guid><description>storage Disk Controller 我们知道定位一个磁盘空间需要三个参数(platter, track, sector). 但是 cpu 不使用这么麻烦的方式, cpu 使用的是逻辑盘号. 也就是磁盘控制器将逻辑盘号翻</description></item><item><title>building-docker-image</title><link>http://stardustman.github.io/2019/05/16/building-docker-image/</link><pubDate>Thu, 16 May 2019 17:33:01 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/building-docker-image/</guid><description>Docker images are built based on a Dockerfile. A Dockerfile defines all the steps required to create a Docker image with your application configured and ready to be run as a container. The image itself contains everything, from operating system to dependencies and configuration required to run your application. Having everything within the image allows you to migrate images between different environments and be confident that if it works in one environment, then it will work in another.</description></item><item><title>deploy-static-website</title><link>http://stardustman.github.io/2019/05/16/deploy-static-website/</link><pubDate>Thu, 16 May 2019 16:17:51 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/deploy-static-website/</guid><description>Create a Dockerfile Docker Images start from a base image. The base image should include the platform dependencies required by your application, for example, having the JVM or CLR installed. This base image is defined as an instruction in the Dockerfile. Docker Images are built based on the contents of a Dockerfile. The Dockerfile is a list of instructions describing how to deploy your application.
# base image FROM nginx:alpine # copies the content of the current directory into a particular location (/usr/share/nginx/html)inside the container.</description></item><item><title>katacoda-deploying-first-docker-container</title><link>http://stardustman.github.io/2019/05/16/katacoda-deploying-first-docker-container/</link><pubDate>Thu, 16 May 2019 12:40:16 +0800</pubDate><guid>http://stardustman.github.io/2019/05/16/katacoda-deploying-first-docker-container/</guid><description>Running a container background(detached) docker search image-name
docker search redis docker run options image-name:version solution1: default latest version
docker run -d redis solution2: version is 3.2
docker run -d redis:3.2 Find running container docker ps docker inspect &amp;lt;container-id&amp;gt; docker logs &amp;lt;container-id&amp;gt; Access redis note: each docker container is sandboxed
solution1: specify host port is 6379 -p host-port:container-post
docker run -d --name redisHostPort -p 6379:6379 redis:latest solution2: specify randomly host port -p container-port</description></item></channel></rss>